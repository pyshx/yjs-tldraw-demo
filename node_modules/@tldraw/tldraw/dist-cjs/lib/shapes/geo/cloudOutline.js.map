{
  "version": 3,
  "sources": ["../../../../src/lib/shapes/geo/cloudOutline.ts"],
  "sourcesContent": ["import {\n\tPI,\n\tTLDefaultSizeStyle,\n\tVec2d,\n\tVec2dModel,\n\tclockwiseAngleDist,\n\tgetPointOnCircle,\n\trng,\n\ttoDomPrecision,\n} from '@tldraw/editor'\n\nfunction getPillCircumference(width: number, height: number) {\n\tconst radius = Math.min(width, height) / 2\n\tconst longSide = Math.max(width, height) - radius * 2\n\n\treturn Math.PI * (radius * 2) + 2 * longSide\n}\n\ntype PillSection =\n\t| {\n\t\t\ttype: 'straight'\n\t\t\tstart: Vec2dModel\n\t\t\tdelta: Vec2dModel\n\t  }\n\t| {\n\t\t\ttype: 'arc'\n\t\t\tcenter: Vec2dModel\n\t\t\tstartAngle: number\n\t  }\n\nexport function getPillPoints(width: number, height: number, numPoints: number) {\n\tconst radius = Math.min(width, height) / 2\n\tconst longSide = Math.max(width, height) - radius * 2\n\n\tconst circumference = Math.PI * (radius * 2) + 2 * longSide\n\n\tconst spacing = circumference / numPoints\n\n\tconst sections: PillSection[] =\n\t\twidth > height\n\t\t\t? [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'straight',\n\t\t\t\t\t\tstart: new Vec2d(radius, 0),\n\t\t\t\t\t\tdelta: new Vec2d(1, 0),\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'arc',\n\t\t\t\t\t\tcenter: new Vec2d(width - radius, radius),\n\t\t\t\t\t\tstartAngle: -PI / 2,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'straight',\n\t\t\t\t\t\tstart: new Vec2d(width - radius, height),\n\t\t\t\t\t\tdelta: new Vec2d(-1, 0),\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'arc',\n\t\t\t\t\t\tcenter: new Vec2d(radius, radius),\n\t\t\t\t\t\tstartAngle: PI / 2,\n\t\t\t\t\t},\n\t\t\t  ]\n\t\t\t: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'straight',\n\t\t\t\t\t\tstart: new Vec2d(width, radius),\n\t\t\t\t\t\tdelta: new Vec2d(0, 1),\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'arc',\n\t\t\t\t\t\tcenter: new Vec2d(radius, height - radius),\n\t\t\t\t\t\tstartAngle: 0,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'straight',\n\t\t\t\t\t\tstart: new Vec2d(0, height - radius),\n\t\t\t\t\t\tdelta: new Vec2d(0, -1),\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'arc',\n\t\t\t\t\t\tcenter: new Vec2d(radius, radius),\n\t\t\t\t\t\tstartAngle: PI,\n\t\t\t\t\t},\n\t\t\t  ]\n\n\tlet sectionOffset = 0\n\n\tconst points: Vec2d[] = []\n\tfor (let i = 0; i < numPoints; i++) {\n\t\tconst section = sections[0]\n\t\tif (section.type === 'straight') {\n\t\t\tpoints.push(Vec2d.Add(section.start, Vec2d.Mul(section.delta, sectionOffset)))\n\t\t} else {\n\t\t\tpoints.push(\n\t\t\t\tgetPointOnCircle(\n\t\t\t\t\tsection.center.x,\n\t\t\t\t\tsection.center.y,\n\t\t\t\t\tradius,\n\t\t\t\t\tsection.startAngle + sectionOffset / radius\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t\tsectionOffset += spacing\n\t\tlet sectionLength = section.type === 'straight' ? longSide : PI * radius\n\t\twhile (sectionOffset > sectionLength) {\n\t\t\tsectionOffset -= sectionLength\n\t\t\tsections.push(sections.shift()!)\n\t\t\tsectionLength = sections[0].type === 'straight' ? longSide : PI * radius\n\t\t}\n\t}\n\n\treturn points\n}\n\nconst switchSize = <T>(size: TLDefaultSizeStyle, s: T, m: T, l: T, xl: T) => {\n\tswitch (size) {\n\t\tcase 's':\n\t\t\treturn s\n\t\tcase 'm':\n\t\t\treturn m\n\t\tcase 'l':\n\t\t\treturn l\n\t\tcase 'xl':\n\t\t\treturn xl\n\t}\n}\n\nexport function getCloudArcs(\n\twidth: number,\n\theight: number,\n\tseed: string,\n\tsize: TLDefaultSizeStyle\n) {\n\tconst getRandom = rng(seed)\n\tconst pillCircumference = getPillCircumference(width, height)\n\tconst numBumps = Math.max(\n\t\tMath.ceil(pillCircumference / switchSize(size, 50, 70, 100, 130)),\n\t\t6,\n\t\tMath.ceil(pillCircumference / Math.min(width, height))\n\t)\n\tconst targetBumpProtrusion = (pillCircumference / numBumps) * 0.2\n\n\t// if the aspect ratio is high, innerWidth should be smaller\n\tconst innerWidth = Math.max(width - targetBumpProtrusion * 2, 1)\n\tconst innerHeight = Math.max(height - targetBumpProtrusion * 2, 1)\n\tconst paddingX = (width - innerWidth) / 2\n\tconst paddingY = (height - innerHeight) / 2\n\n\tconst distanceBetweenPointsOnPerimeter = getPillCircumference(innerWidth, innerHeight) / numBumps\n\n\tconst bumpPoints = getPillPoints(innerWidth, innerHeight, numBumps).map((p) => {\n\t\treturn p.addXY(paddingX, paddingY)\n\t})\n\n\tconst maxWiggleX = width < 20 ? 0 : targetBumpProtrusion * 0.3\n\tconst maxWiggleY = height < 20 ? 0 : targetBumpProtrusion * 0.3\n\n\t// wiggle the points from either end so that the bumps 'pop'\n\t// in at the bottom-right and the top-left looks relatively stable\n\tconst wiggledPoints = bumpPoints.slice(0)\n\tfor (let i = 0; i < Math.floor(numBumps / 2); i++) {\n\t\twiggledPoints[i] = Vec2d.AddXY(\n\t\t\twiggledPoints[i],\n\t\t\tgetRandom() * maxWiggleX,\n\t\t\tgetRandom() * maxWiggleY\n\t\t)\n\t\twiggledPoints[numBumps - i - 1] = Vec2d.AddXY(\n\t\t\twiggledPoints[numBumps - i - 1],\n\t\t\tgetRandom() * maxWiggleX,\n\t\t\tgetRandom() * maxWiggleY\n\t\t)\n\t}\n\n\tconst arcs: Arc[] = []\n\n\tfor (let i = 0; i < wiggledPoints.length; i++) {\n\t\tconst j = i === wiggledPoints.length - 1 ? 0 : i + 1\n\t\tconst leftWigglePoint = wiggledPoints[i]\n\t\tconst rightWigglePoint = wiggledPoints[j]\n\t\tconst leftPoint = bumpPoints[i]\n\t\tconst rightPoint = bumpPoints[j]\n\n\t\tconst midPoint = Vec2d.Average([leftPoint, rightPoint])\n\t\tconst offsetAngle = Vec2d.Angle(leftPoint, rightPoint) - Math.PI / 2\n\t\t// when the points are on the curvy part of a pill, there is a natural arc that we need to extends past\n\t\t// otherwise it looks like the bumps get less bumpy on the curvy parts\n\t\tconst distanceBetweenOriginalPoints = Vec2d.Dist(leftPoint, rightPoint)\n\t\tconst curvatureOffset = distanceBetweenPointsOnPerimeter - distanceBetweenOriginalPoints\n\t\tconst distanceBetweenWigglePoints = Vec2d.Dist(leftWigglePoint, rightWigglePoint)\n\t\tconst relativeSize = distanceBetweenWigglePoints / distanceBetweenOriginalPoints\n\t\tconst finalDistance = (Math.max(paddingX, paddingY) + curvatureOffset) * relativeSize\n\n\t\tconst arcPoint = Vec2d.Add(midPoint, Vec2d.FromAngle(offsetAngle, finalDistance))\n\t\tif (arcPoint.x < 0) {\n\t\t\tarcPoint.x = 0\n\t\t} else if (arcPoint.x > width) {\n\t\t\tarcPoint.x = width\n\t\t}\n\t\tif (arcPoint.y < 0) {\n\t\t\tarcPoint.y = 0\n\t\t} else if (arcPoint.y > height) {\n\t\t\tarcPoint.y = height\n\t\t}\n\n\t\tconst center = getCenterOfCircleGivenThreePoints(leftWigglePoint, rightWigglePoint, arcPoint)\n\t\tconst radius = Vec2d.Dist(\n\t\t\tcenter ? center : Vec2d.Average([leftWigglePoint, rightWigglePoint]),\n\t\t\tleftWigglePoint\n\t\t)\n\n\t\tarcs.push({\n\t\t\tleftPoint: leftWigglePoint,\n\t\t\trightPoint: rightWigglePoint,\n\t\t\tarcPoint,\n\t\t\tcenter,\n\t\t\tradius,\n\t\t})\n\t}\n\n\treturn arcs\n}\n\ntype Arc = {\n\tleftPoint: Vec2d\n\trightPoint: Vec2d\n\tarcPoint: Vec2d\n\tcenter: Vec2d | null\n\tradius: number\n}\n\nfunction getCenterOfCircleGivenThreePoints(a: Vec2d, b: Vec2d, c: Vec2d) {\n\tconst A = a.x * (b.y - c.y) - a.y * (b.x - c.x) + b.x * c.y - c.x * b.y\n\tconst B =\n\t\t(a.x * a.x + a.y * a.y) * (c.y - b.y) +\n\t\t(b.x * b.x + b.y * b.y) * (a.y - c.y) +\n\t\t(c.x * c.x + c.y * c.y) * (b.y - a.y)\n\tconst C =\n\t\t(a.x * a.x + a.y * a.y) * (b.x - c.x) +\n\t\t(b.x * b.x + b.y * b.y) * (c.x - a.x) +\n\t\t(c.x * c.x + c.y * c.y) * (a.x - b.x)\n\n\tconst x = -B / (2 * A)\n\tconst y = -C / (2 * A)\n\n\t// handle situations where the points are colinear (this happens when the cloud is very small)\n\tif (!Number.isFinite(x) || !Number.isFinite(y)) {\n\t\treturn null\n\t}\n\n\treturn new Vec2d(x, y)\n}\n\nexport function cloudOutline(\n\twidth: number,\n\theight: number,\n\tseed: string,\n\tsize: TLDefaultSizeStyle\n) {\n\tconst path: Vec2d[] = []\n\n\tconst arcs = getCloudArcs(width, height, seed, size)\n\n\tfor (const { center, radius, leftPoint, rightPoint } of arcs) {\n\t\tpath.push(...pointsOnArc(leftPoint, rightPoint, center, radius, 10))\n\t}\n\n\treturn path\n}\n\nexport function cloudSvgPath(\n\twidth: number,\n\theight: number,\n\tseed: string,\n\tsize: TLDefaultSizeStyle\n) {\n\t// const points = cloudOutline(width, height, seed, size)\n\t// {\n\t// \tlet path = `M${toDomPrecision(points[0].x)},${toDomPrecision(points[0].y)}`\n\t// \tfor (const point of points.slice(1)) {\n\t// \t\tpath += ` L${toDomPrecision(point.x)},${toDomPrecision(point.y)}`\n\t// \t}\n\t// \treturn path\n\t// }\n\n\tconst arcs = getCloudArcs(width, height, seed, size)\n\tlet path = `M${toDomPrecision(arcs[0].leftPoint.x)},${toDomPrecision(arcs[0].leftPoint.y)}`\n\n\t// now draw arcs for each circle, starting where it intersects the previous circle, and ending where it intersects the next circle\n\tfor (const { leftPoint, rightPoint, radius, center } of arcs) {\n\t\tif (center === null) {\n\t\t\t// draw a line to rightPoint instead\n\t\t\tpath += ` L${toDomPrecision(rightPoint.x)},${toDomPrecision(rightPoint.y)}`\n\t\t\tcontinue\n\t\t}\n\t\t// use the large arc if the center of the circle is to the left of the line between the two points\n\t\tconst arc = isLeft(leftPoint, rightPoint, center) ? '0' : '1'\n\t\tpath += ` A${toDomPrecision(radius)},${toDomPrecision(radius)} 0 ${arc},1 ${toDomPrecision(\n\t\t\trightPoint.x\n\t\t)},${toDomPrecision(rightPoint.y)}`\n\t}\n\n\tpath += ' Z'\n\treturn path\n}\n\nexport function inkyCloudSvgPath(\n\twidth: number,\n\theight: number,\n\tseed: string,\n\tsize: TLDefaultSizeStyle\n) {\n\tconst getRandom = rng(seed)\n\tconst mutMultiplier = size === 's' ? 0.5 : size === 'm' ? 0.7 : size === 'l' ? 0.9 : 1.6\n\tconst mut = (n: number) => {\n\t\treturn n + getRandom() * mutMultiplier * 2\n\t}\n\tconst arcs = getCloudArcs(width, height, seed, size)\n\tconst avgArcLength =\n\t\tarcs.reduce((sum, arc) => sum + Vec2d.Dist(arc.leftPoint, arc.rightPoint), 0) / arcs.length\n\tconst shouldMutatePoints = avgArcLength > mutMultiplier * 15\n\n\tconst mutPoint = shouldMutatePoints\n\t\t? (p: Vec2d) => new Vec2d(mut(p.x), mut(p.y))\n\t\t: (p: Vec2d) => p\n\tlet pathA = `M${toDomPrecision(arcs[0].leftPoint.x)},${toDomPrecision(arcs[0].leftPoint.y)}`\n\tlet leftMutPoint = mutPoint(arcs[0].leftPoint)\n\tlet pathB = `M${toDomPrecision(leftMutPoint.x)},${toDomPrecision(leftMutPoint.y)}`\n\n\tfor (const { leftPoint, center, rightPoint, radius, arcPoint } of arcs) {\n\t\tif (center === null) {\n\t\t\t// draw a line to rightPoint instead\n\t\t\tpathA += ` L${toDomPrecision(rightPoint.x)},${toDomPrecision(rightPoint.y)}`\n\t\t\tconst rightMutPoint = mutPoint(rightPoint)\n\t\t\tpathB += ` L${toDomPrecision(rightMutPoint.x)},${toDomPrecision(rightMutPoint.y)}`\n\t\t\tleftMutPoint = rightMutPoint\n\t\t\tcontinue\n\t\t}\n\t\tconst arc = isLeft(leftPoint, rightPoint, center) ? '0' : '1'\n\t\tpathA += ` A${toDomPrecision(radius)},${toDomPrecision(radius)} 0 ${arc},1 ${toDomPrecision(\n\t\t\trightPoint.x\n\t\t)},${toDomPrecision(rightPoint.y)}`\n\t\tconst rightMutPoint = mutPoint(rightPoint)\n\t\tconst mutArcPoint = mutPoint(arcPoint)\n\t\tconst mutCenter = getCenterOfCircleGivenThreePoints(leftMutPoint, rightMutPoint, mutArcPoint)\n\t\tif (!mutCenter) {\n\t\t\t// draw a line to rightMutPoint instead\n\t\t\tpathB += ` L${toDomPrecision(rightMutPoint.x)},${toDomPrecision(rightMutPoint.y)}`\n\t\t\tleftMutPoint = rightMutPoint\n\t\t\tcontinue\n\t\t}\n\t\tconst mutRadius = Math.abs(Vec2d.Dist(mutCenter, leftMutPoint))\n\n\t\tpathB += ` A${toDomPrecision(mutRadius)},${toDomPrecision(\n\t\t\tmutRadius\n\t\t)} 0 ${arc},1 ${toDomPrecision(rightMutPoint.x)},${toDomPrecision(rightMutPoint.y)}`\n\t\tleftMutPoint = rightMutPoint\n\t}\n\n\treturn pathA + pathB + ' Z'\n}\n\nexport function pointsOnArc(\n\tstartPoint: Vec2dModel,\n\tendPoint: Vec2dModel,\n\tcenter: Vec2dModel | null,\n\tradius: number,\n\tnumPoints: number\n): Vec2d[] {\n\tif (center === null) {\n\t\treturn [Vec2d.From(startPoint), Vec2d.From(endPoint)]\n\t}\n\tconst results: Vec2d[] = []\n\n\tconst startAngle = Vec2d.Angle(center, startPoint)\n\tconst endAngle = Vec2d.Angle(center, endPoint)\n\n\tconst l = clockwiseAngleDist(startAngle, endAngle)\n\n\tfor (let i = 0; i < numPoints; i++) {\n\t\tconst t = i / (numPoints - 1)\n\t\tconst angle = startAngle + l * t\n\t\tconst point = getPointOnCircle(center.x, center.y, radius, angle)\n\t\tresults.push(point)\n\t}\n\n\treturn results\n}\n\nfunction isLeft(a: Vec2d, b: Vec2d, c: Vec2d) {\n\treturn (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x) > 0\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBASO;AAEP,SAAS,qBAAqB,OAAe,QAAgB;AAC5D,QAAM,SAAS,KAAK,IAAI,OAAO,MAAM,IAAI;AACzC,QAAM,WAAW,KAAK,IAAI,OAAO,MAAM,IAAI,SAAS;AAEpD,SAAO,KAAK,MAAM,SAAS,KAAK,IAAI;AACrC;AAcO,SAAS,cAAc,OAAe,QAAgB,WAAmB;AAC/E,QAAM,SAAS,KAAK,IAAI,OAAO,MAAM,IAAI;AACzC,QAAM,WAAW,KAAK,IAAI,OAAO,MAAM,IAAI,SAAS;AAEpD,QAAM,gBAAgB,KAAK,MAAM,SAAS,KAAK,IAAI;AAEnD,QAAM,UAAU,gBAAgB;AAEhC,QAAM,WACL,QAAQ,SACL;AAAA,IACA;AAAA,MACC,MAAM;AAAA,MACN,OAAO,IAAI,oBAAM,QAAQ,CAAC;AAAA,MAC1B,OAAO,IAAI,oBAAM,GAAG,CAAC;AAAA,IACtB;AAAA,IACA;AAAA,MACC,MAAM;AAAA,MACN,QAAQ,IAAI,oBAAM,QAAQ,QAAQ,MAAM;AAAA,MACxC,YAAY,CAAC,mBAAK;AAAA,IACnB;AAAA,IACA;AAAA,MACC,MAAM;AAAA,MACN,OAAO,IAAI,oBAAM,QAAQ,QAAQ,MAAM;AAAA,MACvC,OAAO,IAAI,oBAAM,IAAI,CAAC;AAAA,IACvB;AAAA,IACA;AAAA,MACC,MAAM;AAAA,MACN,QAAQ,IAAI,oBAAM,QAAQ,MAAM;AAAA,MAChC,YAAY,mBAAK;AAAA,IAClB;AAAA,EACA,IACA;AAAA,IACA;AAAA,MACC,MAAM;AAAA,MACN,OAAO,IAAI,oBAAM,OAAO,MAAM;AAAA,MAC9B,OAAO,IAAI,oBAAM,GAAG,CAAC;AAAA,IACtB;AAAA,IACA;AAAA,MACC,MAAM;AAAA,MACN,QAAQ,IAAI,oBAAM,QAAQ,SAAS,MAAM;AAAA,MACzC,YAAY;AAAA,IACb;AAAA,IACA;AAAA,MACC,MAAM;AAAA,MACN,OAAO,IAAI,oBAAM,GAAG,SAAS,MAAM;AAAA,MACnC,OAAO,IAAI,oBAAM,GAAG,EAAE;AAAA,IACvB;AAAA,IACA;AAAA,MACC,MAAM;AAAA,MACN,QAAQ,IAAI,oBAAM,QAAQ,MAAM;AAAA,MAChC,YAAY;AAAA,IACb;AAAA,EACA;AAEJ,MAAI,gBAAgB;AAEpB,QAAM,SAAkB,CAAC;AACzB,WAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AACnC,UAAM,UAAU,SAAS,CAAC;AAC1B,QAAI,QAAQ,SAAS,YAAY;AAChC,aAAO,KAAK,oBAAM,IAAI,QAAQ,OAAO,oBAAM,IAAI,QAAQ,OAAO,aAAa,CAAC,CAAC;AAAA,IAC9E,OAAO;AACN,aAAO;AAAA,YACN;AAAA,UACC,QAAQ,OAAO;AAAA,UACf,QAAQ,OAAO;AAAA,UACf;AAAA,UACA,QAAQ,aAAa,gBAAgB;AAAA,QACtC;AAAA,MACD;AAAA,IACD;AACA,qBAAiB;AACjB,QAAI,gBAAgB,QAAQ,SAAS,aAAa,WAAW,mBAAK;AAClE,WAAO,gBAAgB,eAAe;AACrC,uBAAiB;AACjB,eAAS,KAAK,SAAS,MAAM,CAAE;AAC/B,sBAAgB,SAAS,CAAC,EAAE,SAAS,aAAa,WAAW,mBAAK;AAAA,IACnE;AAAA,EACD;AAEA,SAAO;AACR;AAEA,MAAM,aAAa,CAAI,MAA0B,GAAM,GAAM,GAAM,OAAU;AAC5E,UAAQ,MAAM;AAAA,IACb,KAAK;AACJ,aAAO;AAAA,IACR,KAAK;AACJ,aAAO;AAAA,IACR,KAAK;AACJ,aAAO;AAAA,IACR,KAAK;AACJ,aAAO;AAAA,EACT;AACD;AAEO,SAAS,aACf,OACA,QACA,MACA,MACC;AACD,QAAM,gBAAY,mBAAI,IAAI;AAC1B,QAAM,oBAAoB,qBAAqB,OAAO,MAAM;AAC5D,QAAM,WAAW,KAAK;AAAA,IACrB,KAAK,KAAK,oBAAoB,WAAW,MAAM,IAAI,IAAI,KAAK,GAAG,CAAC;AAAA,IAChE;AAAA,IACA,KAAK,KAAK,oBAAoB,KAAK,IAAI,OAAO,MAAM,CAAC;AAAA,EACtD;AACA,QAAM,uBAAwB,oBAAoB,WAAY;AAG9D,QAAM,aAAa,KAAK,IAAI,QAAQ,uBAAuB,GAAG,CAAC;AAC/D,QAAM,cAAc,KAAK,IAAI,SAAS,uBAAuB,GAAG,CAAC;AACjE,QAAM,YAAY,QAAQ,cAAc;AACxC,QAAM,YAAY,SAAS,eAAe;AAE1C,QAAM,mCAAmC,qBAAqB,YAAY,WAAW,IAAI;AAEzF,QAAM,aAAa,cAAc,YAAY,aAAa,QAAQ,EAAE,IAAI,CAAC,MAAM;AAC9E,WAAO,EAAE,MAAM,UAAU,QAAQ;AAAA,EAClC,CAAC;AAED,QAAM,aAAa,QAAQ,KAAK,IAAI,uBAAuB;AAC3D,QAAM,aAAa,SAAS,KAAK,IAAI,uBAAuB;AAI5D,QAAM,gBAAgB,WAAW,MAAM,CAAC;AACxC,WAAS,IAAI,GAAG,IAAI,KAAK,MAAM,WAAW,CAAC,GAAG,KAAK;AAClD,kBAAc,CAAC,IAAI,oBAAM;AAAA,MACxB,cAAc,CAAC;AAAA,MACf,UAAU,IAAI;AAAA,MACd,UAAU,IAAI;AAAA,IACf;AACA,kBAAc,WAAW,IAAI,CAAC,IAAI,oBAAM;AAAA,MACvC,cAAc,WAAW,IAAI,CAAC;AAAA,MAC9B,UAAU,IAAI;AAAA,MACd,UAAU,IAAI;AAAA,IACf;AAAA,EACD;AAEA,QAAM,OAAc,CAAC;AAErB,WAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC9C,UAAM,IAAI,MAAM,cAAc,SAAS,IAAI,IAAI,IAAI;AACnD,UAAM,kBAAkB,cAAc,CAAC;AACvC,UAAM,mBAAmB,cAAc,CAAC;AACxC,UAAM,YAAY,WAAW,CAAC;AAC9B,UAAM,aAAa,WAAW,CAAC;AAE/B,UAAM,WAAW,oBAAM,QAAQ,CAAC,WAAW,UAAU,CAAC;AACtD,UAAM,cAAc,oBAAM,MAAM,WAAW,UAAU,IAAI,KAAK,KAAK;AAGnE,UAAM,gCAAgC,oBAAM,KAAK,WAAW,UAAU;AACtE,UAAM,kBAAkB,mCAAmC;AAC3D,UAAM,8BAA8B,oBAAM,KAAK,iBAAiB,gBAAgB;AAChF,UAAM,eAAe,8BAA8B;AACnD,UAAM,iBAAiB,KAAK,IAAI,UAAU,QAAQ,IAAI,mBAAmB;AAEzE,UAAM,WAAW,oBAAM,IAAI,UAAU,oBAAM,UAAU,aAAa,aAAa,CAAC;AAChF,QAAI,SAAS,IAAI,GAAG;AACnB,eAAS,IAAI;AAAA,IACd,WAAW,SAAS,IAAI,OAAO;AAC9B,eAAS,IAAI;AAAA,IACd;AACA,QAAI,SAAS,IAAI,GAAG;AACnB,eAAS,IAAI;AAAA,IACd,WAAW,SAAS,IAAI,QAAQ;AAC/B,eAAS,IAAI;AAAA,IACd;AAEA,UAAM,SAAS,kCAAkC,iBAAiB,kBAAkB,QAAQ;AAC5F,UAAM,SAAS,oBAAM;AAAA,MACpB,SAAS,SAAS,oBAAM,QAAQ,CAAC,iBAAiB,gBAAgB,CAAC;AAAA,MACnE;AAAA,IACD;AAEA,SAAK,KAAK;AAAA,MACT,WAAW;AAAA,MACX,YAAY;AAAA,MACZ;AAAA,MACA;AAAA,MACA;AAAA,IACD,CAAC;AAAA,EACF;AAEA,SAAO;AACR;AAUA,SAAS,kCAAkC,GAAU,GAAU,GAAU;AACxE,QAAM,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE;AACtE,QAAM,KACJ,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,MAClC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,MAClC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE;AACpC,QAAM,KACJ,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,MAClC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,MAClC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE;AAEpC,QAAM,IAAI,CAAC,KAAK,IAAI;AACpB,QAAM,IAAI,CAAC,KAAK,IAAI;AAGpB,MAAI,CAAC,OAAO,SAAS,CAAC,KAAK,CAAC,OAAO,SAAS,CAAC,GAAG;AAC/C,WAAO;AAAA,EACR;AAEA,SAAO,IAAI,oBAAM,GAAG,CAAC;AACtB;AAEO,SAAS,aACf,OACA,QACA,MACA,MACC;AACD,QAAM,OAAgB,CAAC;AAEvB,QAAM,OAAO,aAAa,OAAO,QAAQ,MAAM,IAAI;AAEnD,aAAW,EAAE,QAAQ,QAAQ,WAAW,WAAW,KAAK,MAAM;AAC7D,SAAK,KAAK,GAAG,YAAY,WAAW,YAAY,QAAQ,QAAQ,EAAE,CAAC;AAAA,EACpE;AAEA,SAAO;AACR;AAEO,SAAS,aACf,OACA,QACA,MACA,MACC;AAUD,QAAM,OAAO,aAAa,OAAO,QAAQ,MAAM,IAAI;AACnD,MAAI,OAAO,QAAI,8BAAe,KAAK,CAAC,EAAE,UAAU,CAAC,CAAC,QAAI,8BAAe,KAAK,CAAC,EAAE,UAAU,CAAC,CAAC;AAGzF,aAAW,EAAE,WAAW,YAAY,QAAQ,OAAO,KAAK,MAAM;AAC7D,QAAI,WAAW,MAAM;AAEpB,cAAQ,SAAK,8BAAe,WAAW,CAAC,CAAC,QAAI,8BAAe,WAAW,CAAC,CAAC;AACzE;AAAA,IACD;AAEA,UAAM,MAAM,OAAO,WAAW,YAAY,MAAM,IAAI,MAAM;AAC1D,YAAQ,SAAK,8BAAe,MAAM,CAAC,QAAI,8BAAe,MAAM,CAAC,MAAM,GAAG,UAAM;AAAA,MAC3E,WAAW;AAAA,IACZ,CAAC,QAAI,8BAAe,WAAW,CAAC,CAAC;AAAA,EAClC;AAEA,UAAQ;AACR,SAAO;AACR;AAEO,SAAS,iBACf,OACA,QACA,MACA,MACC;AACD,QAAM,gBAAY,mBAAI,IAAI;AAC1B,QAAM,gBAAgB,SAAS,MAAM,MAAM,SAAS,MAAM,MAAM,SAAS,MAAM,MAAM;AACrF,QAAM,MAAM,CAAC,MAAc;AAC1B,WAAO,IAAI,UAAU,IAAI,gBAAgB;AAAA,EAC1C;AACA,QAAM,OAAO,aAAa,OAAO,QAAQ,MAAM,IAAI;AACnD,QAAM,eACL,KAAK,OAAO,CAAC,KAAK,QAAQ,MAAM,oBAAM,KAAK,IAAI,WAAW,IAAI,UAAU,GAAG,CAAC,IAAI,KAAK;AACtF,QAAM,qBAAqB,eAAe,gBAAgB;AAE1D,QAAM,WAAW,qBACd,CAAC,MAAa,IAAI,oBAAM,IAAI,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,CAAC,IAC1C,CAAC,MAAa;AACjB,MAAI,QAAQ,QAAI,8BAAe,KAAK,CAAC,EAAE,UAAU,CAAC,CAAC,QAAI,8BAAe,KAAK,CAAC,EAAE,UAAU,CAAC,CAAC;AAC1F,MAAI,eAAe,SAAS,KAAK,CAAC,EAAE,SAAS;AAC7C,MAAI,QAAQ,QAAI,8BAAe,aAAa,CAAC,CAAC,QAAI,8BAAe,aAAa,CAAC,CAAC;AAEhF,aAAW,EAAE,WAAW,QAAQ,YAAY,QAAQ,SAAS,KAAK,MAAM;AACvE,QAAI,WAAW,MAAM;AAEpB,eAAS,SAAK,8BAAe,WAAW,CAAC,CAAC,QAAI,8BAAe,WAAW,CAAC,CAAC;AAC1E,YAAMA,iBAAgB,SAAS,UAAU;AACzC,eAAS,SAAK,8BAAeA,eAAc,CAAC,CAAC,QAAI,8BAAeA,eAAc,CAAC,CAAC;AAChF,qBAAeA;AACf;AAAA,IACD;AACA,UAAM,MAAM,OAAO,WAAW,YAAY,MAAM,IAAI,MAAM;AAC1D,aAAS,SAAK,8BAAe,MAAM,CAAC,QAAI,8BAAe,MAAM,CAAC,MAAM,GAAG,UAAM;AAAA,MAC5E,WAAW;AAAA,IACZ,CAAC,QAAI,8BAAe,WAAW,CAAC,CAAC;AACjC,UAAM,gBAAgB,SAAS,UAAU;AACzC,UAAM,cAAc,SAAS,QAAQ;AACrC,UAAM,YAAY,kCAAkC,cAAc,eAAe,WAAW;AAC5F,QAAI,CAAC,WAAW;AAEf,eAAS,SAAK,8BAAe,cAAc,CAAC,CAAC,QAAI,8BAAe,cAAc,CAAC,CAAC;AAChF,qBAAe;AACf;AAAA,IACD;AACA,UAAM,YAAY,KAAK,IAAI,oBAAM,KAAK,WAAW,YAAY,CAAC;AAE9D,aAAS,SAAK,8BAAe,SAAS,CAAC,QAAI;AAAA,MAC1C;AAAA,IACD,CAAC,MAAM,GAAG,UAAM,8BAAe,cAAc,CAAC,CAAC,QAAI,8BAAe,cAAc,CAAC,CAAC;AAClF,mBAAe;AAAA,EAChB;AAEA,SAAO,QAAQ,QAAQ;AACxB;AAEO,SAAS,YACf,YACA,UACA,QACA,QACA,WACU;AACV,MAAI,WAAW,MAAM;AACpB,WAAO,CAAC,oBAAM,KAAK,UAAU,GAAG,oBAAM,KAAK,QAAQ,CAAC;AAAA,EACrD;AACA,QAAM,UAAmB,CAAC;AAE1B,QAAM,aAAa,oBAAM,MAAM,QAAQ,UAAU;AACjD,QAAM,WAAW,oBAAM,MAAM,QAAQ,QAAQ;AAE7C,QAAM,QAAI,kCAAmB,YAAY,QAAQ;AAEjD,WAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AACnC,UAAM,IAAI,KAAK,YAAY;AAC3B,UAAM,QAAQ,aAAa,IAAI;AAC/B,UAAM,YAAQ,gCAAiB,OAAO,GAAG,OAAO,GAAG,QAAQ,KAAK;AAChE,YAAQ,KAAK,KAAK;AAAA,EACnB;AAEA,SAAO;AACR;AAEA,SAAS,OAAO,GAAU,GAAU,GAAU;AAC7C,UAAQ,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,KAAK;AAChE;",
  "names": ["rightMutPoint"]
}
