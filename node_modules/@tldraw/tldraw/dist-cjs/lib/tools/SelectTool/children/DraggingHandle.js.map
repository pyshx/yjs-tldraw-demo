{
  "version": 3,
  "sources": ["../../../../../src/lib/tools/SelectTool/children/DraggingHandle.ts"],
  "sourcesContent": ["import {\n\tMatrix2d,\n\tStateNode,\n\tTLArrowShape,\n\tTLArrowShapeTerminal,\n\tTLCancelEvent,\n\tTLEnterEventHandler,\n\tTLEventHandlers,\n\tTLHandle,\n\tTLKeyboardEvent,\n\tTLPointerEventInfo,\n\tTLShapeId,\n\tTLShapePartial,\n\tVec2d,\n\tdeepCopy,\n\tsnapAngle,\n\tsortByIndex,\n} from '@tldraw/editor'\n\nexport class DraggingHandle extends StateNode {\n\tstatic override id = 'dragging_handle'\n\n\tshapeId = '' as TLShapeId\n\tinitialHandle = {} as TLHandle\n\tinitialAdjacentHandle = null as TLHandle | null\n\tinitialPagePoint = {} as Vec2d\n\n\tmarkId = ''\n\tinitialPageTransform: any\n\tinitialPageRotation: any\n\n\tinfo = {} as TLPointerEventInfo & {\n\t\tshape: TLArrowShape\n\t\ttarget: 'handle'\n\t\tonInteractionEnd?: string\n\t\tisCreating: boolean\n\t}\n\n\tisPrecise = false\n\tisPreciseId = null as TLShapeId | null\n\tpointingId = null as TLShapeId | null\n\n\toverride onEnter: TLEnterEventHandler = (\n\t\tinfo: TLPointerEventInfo & {\n\t\t\tshape: TLArrowShape\n\t\t\ttarget: 'handle'\n\t\t\tonInteractionEnd?: string\n\t\t\tisCreating: boolean\n\t\t}\n\t) => {\n\t\tconst { shape, isCreating, handle } = info\n\t\tthis.info = info\n\t\tthis.parent.currentToolIdMask = info.onInteractionEnd\n\t\tthis.shapeId = shape.id\n\t\tthis.markId = isCreating ? `creating:${shape.id}` : 'dragging handle'\n\t\tif (!isCreating) this.editor.mark(this.markId)\n\t\tthis.initialHandle = deepCopy(handle)\n\t\tthis.initialPageTransform = this.editor.getShapePageTransform(shape)!\n\t\tthis.initialPageRotation = this.initialPageTransform.rotation()\n\t\tthis.initialPagePoint = this.editor.inputs.originPagePoint.clone()\n\n\t\tthis.editor.updateInstanceState(\n\t\t\t{ cursor: { type: isCreating ? 'cross' : 'grabbing', rotation: 0 } },\n\t\t\t{ ephemeral: true }\n\t\t)\n\n\t\t// <!-- Only relevant to arrows\n\t\tconst handles = this.editor.getShapeHandles(shape)!.sort(sortByIndex)\n\t\tconst index = handles.findIndex((h) => h.id === info.handle.id)\n\n\t\t// Find the adjacent handle\n\t\tthis.initialAdjacentHandle = null\n\n\t\t// Start from the handle and work forward\n\t\tfor (let i = index + 1; i < handles.length; i++) {\n\t\t\tconst handle = handles[i]\n\t\t\tif (handle.type === 'vertex' && handle.id !== 'middle' && handle.id !== info.handle.id) {\n\t\t\t\tthis.initialAdjacentHandle = handle\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// If still no handle, start from the end and work backward\n\t\tif (!this.initialAdjacentHandle) {\n\t\t\tfor (let i = handles.length - 1; i >= 0; i--) {\n\t\t\t\tconst handle = handles[i]\n\t\t\t\tif (handle.type === 'vertex' && handle.id !== 'middle' && handle.id !== info.handle.id) {\n\t\t\t\t\tthis.initialAdjacentHandle = handle\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst initialTerminal = shape.props[info.handle.id as 'start' | 'end']\n\n\t\tthis.isPrecise = false\n\n\t\tif (initialTerminal?.type === 'binding') {\n\t\t\tthis.editor.setHintingShapes([initialTerminal.boundShapeId])\n\n\t\t\tthis.isPrecise = !Vec2d.Equals(initialTerminal.normalizedAnchor, { x: 0.5, y: 0.5 })\n\t\t\tif (this.isPrecise) {\n\t\t\t\tthis.isPreciseId = initialTerminal.boundShapeId\n\t\t\t} else {\n\t\t\t\tthis.resetExactTimeout()\n\t\t\t}\n\t\t} else {\n\t\t\tthis.editor.setHintingShapes([])\n\t\t}\n\t\t// -->\n\n\t\tthis.update()\n\n\t\tthis.editor.select(this.shapeId)\n\t}\n\n\t// Only relevant to arrows\n\tprivate exactTimeout = -1 as any\n\n\t// Only relevant to arrows\n\tprivate resetExactTimeout() {\n\t\tif (this.exactTimeout !== -1) {\n\t\t\tthis.clearExactTimeout()\n\t\t}\n\n\t\tthis.exactTimeout = setTimeout(() => {\n\t\t\tif (this.isActive && !this.isPrecise) {\n\t\t\t\tthis.isPrecise = true\n\t\t\t\tthis.isPreciseId = this.pointingId\n\t\t\t\tthis.update()\n\t\t\t}\n\t\t\tthis.exactTimeout = -1\n\t\t}, 750)\n\t}\n\n\t// Only relevant to arrows\n\tprivate clearExactTimeout() {\n\t\tif (this.exactTimeout !== -1) {\n\t\t\tclearTimeout(this.exactTimeout)\n\t\t\tthis.exactTimeout = -1\n\t\t}\n\t}\n\n\toverride onPointerMove: TLEventHandlers['onPointerMove'] = () => {\n\t\tthis.update()\n\t}\n\n\toverride onKeyDown: TLKeyboardEvent | undefined = () => {\n\t\tthis.update()\n\t}\n\n\toverride onKeyUp: TLKeyboardEvent | undefined = () => {\n\t\tthis.update()\n\t}\n\n\toverride onPointerUp: TLEventHandlers['onPointerUp'] = () => {\n\t\tthis.complete()\n\t}\n\n\toverride onComplete: TLEventHandlers['onComplete'] = () => {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel: TLCancelEvent = () => {\n\t\tthis.cancel()\n\t}\n\n\toverride onExit = () => {\n\t\tthis.parent.currentToolIdMask = undefined\n\t\tthis.editor.setHintingShapes([])\n\t\tthis.editor.snaps.clear()\n\t\tthis.editor.updateInstanceState(\n\t\t\t{ cursor: { type: 'default', rotation: 0 } },\n\t\t\t{ ephemeral: true }\n\t\t)\n\t}\n\n\tprivate complete() {\n\t\tthis.editor.snaps.clear()\n\n\t\tconst { onInteractionEnd } = this.info\n\t\tif (this.editor.instanceState.isToolLocked && onInteractionEnd) {\n\t\t\t// Return to the tool that was active before this one,\n\t\t\t// but only if tool lock is turned on!\n\t\t\tthis.editor.setCurrentTool(onInteractionEnd, { shapeId: this.shapeId })\n\t\t\treturn\n\t\t}\n\n\t\tthis.parent.transition('idle', {})\n\t}\n\n\tprivate cancel() {\n\t\tthis.editor.bailToMark(this.markId)\n\t\tthis.editor.snaps.clear()\n\n\t\tconst { onInteractionEnd } = this.info\n\t\tif (onInteractionEnd) {\n\t\t\t// Return to the tool that was active before this one,\n\t\t\t// whether tool lock is turned on or not!\n\t\t\tthis.editor.setCurrentTool(onInteractionEnd, { shapeId: this.shapeId })\n\t\t\treturn\n\t\t}\n\n\t\tthis.parent.transition('idle', {})\n\t}\n\n\tprivate update() {\n\t\tconst { editor, shapeId, initialPagePoint } = this\n\t\tconst { initialHandle, initialPageRotation, initialAdjacentHandle } = this\n\t\tconst {\n\t\t\tuser: { isSnapMode },\n\t\t\thintingShapeIds,\n\t\t\tsnaps,\n\t\t\tinputs: { currentPagePoint, shiftKey, ctrlKey, altKey, pointerVelocity },\n\t\t} = editor\n\n\t\tconst shape = editor.getShape(shapeId)\n\t\tif (!shape) return\n\n\t\tconst util = editor.getShapeUtil(shape)\n\n\t\tlet point = currentPagePoint\n\t\t\t.clone()\n\t\t\t.sub(initialPagePoint)\n\t\t\t.rot(-initialPageRotation)\n\t\t\t.add(initialHandle)\n\n\t\tif (shiftKey && initialAdjacentHandle && initialHandle.id !== 'middle') {\n\t\t\tconst angle = Vec2d.Angle(initialAdjacentHandle, point)\n\t\t\tconst snappedAngle = snapAngle(angle, 24)\n\t\t\tconst angleDifference = snappedAngle - angle\n\t\t\tpoint = Vec2d.RotWith(point, initialAdjacentHandle, angleDifference)\n\t\t}\n\n\t\t// Clear any existing snaps\n\t\teditor.snaps.clear()\n\n\t\tif (initialHandle.canSnap && (isSnapMode ? !ctrlKey : ctrlKey)) {\n\t\t\t// We're snapping\n\t\t\tconst pageTransform = editor.getShapePageTransform(shape.id)\n\t\t\tif (!pageTransform) throw Error('Expected a page transform')\n\n\t\t\t// We want to skip the segments that include the handle, so\n\t\t\t// find the index of the handle that shares the same index property\n\t\t\t// as the initial dragging handle; this catches a quirk of create handles\n\t\t\tconst handleIndex = editor\n\t\t\t\t.getShapeHandles(shape)!\n\t\t\t\t.filter(({ type }) => type === 'vertex')\n\t\t\t\t.sort(sortByIndex)\n\t\t\t\t.findIndex(({ index }) => initialHandle.index === index)\n\n\t\t\t// Get all the outline segments from the shape\n\t\t\tconst additionalSegments = util\n\t\t\t\t.getOutlineSegments(shape)\n\t\t\t\t.map((segment) => Matrix2d.applyToPoints(pageTransform, segment))\n\t\t\t\t.filter((_segment, i) => i !== handleIndex - 1 && i !== handleIndex)\n\n\t\t\tconst snapDelta = snaps.getSnappingHandleDelta({\n\t\t\t\tadditionalSegments,\n\t\t\t\thandlePoint: Matrix2d.applyToPoint(pageTransform, point),\n\t\t\t})\n\n\t\t\tif (snapDelta) {\n\t\t\t\tsnapDelta.rot(-editor.getShapeParentTransform(shape)!.rotation())\n\t\t\t\tpoint.add(snapDelta)\n\t\t\t}\n\t\t}\n\n\t\tconst changes = util.onHandleChange?.(shape, {\n\t\t\thandle: {\n\t\t\t\t...initialHandle,\n\t\t\t\tx: point.x,\n\t\t\t\ty: point.y,\n\t\t\t},\n\t\t\tisPrecise: this.isPrecise || altKey,\n\t\t})\n\n\t\tconst next: TLShapePartial<any> = { ...shape, ...changes }\n\n\t\t// Arrows\n\t\tif (initialHandle.canBind) {\n\t\t\tconst bindingAfter = (next.props as any)[initialHandle.id] as TLArrowShapeTerminal | undefined\n\n\t\t\tif (bindingAfter?.type === 'binding') {\n\t\t\t\tif (hintingShapeIds[0] !== bindingAfter.boundShapeId) {\n\t\t\t\t\teditor.setHintingShapes([bindingAfter.boundShapeId])\n\t\t\t\t\tthis.pointingId = bindingAfter.boundShapeId\n\t\t\t\t\tthis.isPrecise = pointerVelocity.len() < 0.5 || altKey\n\t\t\t\t\tthis.isPreciseId = this.isPrecise ? bindingAfter.boundShapeId : null\n\t\t\t\t\tthis.resetExactTimeout()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (hintingShapeIds.length > 0) {\n\t\t\t\t\teditor.setHintingShapes([])\n\t\t\t\t\tthis.pointingId = null\n\t\t\t\t\tthis.isPrecise = false\n\t\t\t\t\tthis.isPreciseId = null\n\t\t\t\t\tthis.resetExactTimeout()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (changes) {\n\t\t\teditor.updateShapes([next], { squashing: true })\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": ["handle"]
}
