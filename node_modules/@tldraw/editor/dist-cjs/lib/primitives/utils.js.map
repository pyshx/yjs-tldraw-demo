{
  "version": 3,
  "sources": ["../../../src/lib/primitives/utils.ts"],
  "sourcesContent": ["import { Box2d } from './Box2d'\nimport { Vec2d, VecLike } from './Vec2d'\n\n/** @public */\nexport function precise(A: VecLike) {\n\treturn `${toDomPrecision(A.x)},${toDomPrecision(A.y)} `\n}\n\n/** @public */\nexport function average(A: VecLike, B: VecLike) {\n\treturn `${toDomPrecision((A.x + B.x) / 2)},${toDomPrecision((A.y + B.y) / 2)} `\n}\n\n/** @public */\nexport const PI = Math.PI\n/** @public */\nexport const TAU = PI / 2\n/** @public */\nexport const PI2 = PI * 2\n/** @public */\nexport const EPSILON = Math.PI / 180\n/** @public */\nexport const SIN = Math.sin\n\n/**\n * Clamp a value into a range.\n *\n * @example\n *\n * ```ts\n * const A = clamp(0, 1) // 1\n * ```\n *\n * @param n - The number to clamp.\n * @param min - The minimum value.\n * @public\n */\nexport function clamp(n: number, min: number): number\n/**\n * Clamp a value into a range.\n *\n * @example\n *\n * ```ts\n * const A = clamp(0, 1, 10) // 1\n * const B = clamp(11, 1, 10) // 10\n * const C = clamp(5, 1, 10) // 5\n * ```\n *\n * @param n - The number to clamp.\n * @param min - The minimum value.\n * @param max - The maximum value.\n * @public\n */\nexport function clamp(n: number, min: number, max: number): number\nexport function clamp(n: number, min: number, max?: number): number {\n\treturn Math.max(min, typeof max !== 'undefined' ? Math.min(n, max) : n)\n}\n\n/**\n * Get a number to a precision.\n *\n * @param n - The number.\n * @param precision - The precision.\n * @public\n */\nexport function toPrecision(n: number, precision = 10000000000) {\n\tif (!n) return 0\n\treturn Math.round(n * precision) / precision\n}\n\n/**\n * Whether two numbers numbers a and b are approximately equal.\n *\n * @param a - The first point.\n * @param b - The second point.\n * @public\n */\nexport function approximately(a: number, b: number, precision = 0.000001) {\n\treturn Math.abs(a - b) <= precision\n}\n\n/**\n * Find the approximate perimeter of an ellipse.\n *\n * @param rx - The ellipse's x radius.\n * @param ry - The ellipse's y radius.\n * @public\n */\nexport function perimeterOfEllipse(rx: number, ry: number): number {\n\tconst h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2)\n\tconst p = PI * (rx + ry) * (1 + (3 * h) / (10 + Math.sqrt(4 - 3 * h)))\n\treturn p\n}\n\n/**\n * @param a - Any angle in radians\n * @returns A number between 0 and 2 * PI\n * @public\n */\nexport function canonicalizeRotation(a: number) {\n\ta = a % PI2\n\tif (a < 0) {\n\t\ta = a + PI2\n\t} else if (a === 0) {\n\t\t// prevent negative zero\n\t\ta = 0\n\t}\n\treturn a\n}\n\n/**\n * Get the clockwise angle distance between two angles.\n *\n * @param a0 - The first angle.\n * @param a1 - The second angle.\n * @public\n */\nexport function clockwiseAngleDist(a0: number, a1: number): number {\n\ta0 = canonicalizeRotation(a0)\n\ta1 = canonicalizeRotation(a1)\n\tif (a0 > a1) {\n\t\ta1 += PI2\n\t}\n\treturn a1 - a0\n}\n\n/**\n * Get the counter-clockwise angle distance between two angles.\n *\n * @param a0 - The first angle.\n * @param a1 - The second angle.\n * @public\n */\nexport function counterClockwiseAngleDist(a0: number, a1: number): number {\n\treturn PI2 - clockwiseAngleDist(a0, a1)\n}\n\n/**\n * Get the short angle distance between two angles.\n *\n * @param a0 - The first angle.\n * @param a1 - The second angle.\n * @public\n */\nexport function shortAngleDist(a0: number, a1: number): number {\n\tconst da = (a1 - a0) % PI2\n\treturn ((2 * da) % PI2) - da\n}\n\n/**\n * Get the long angle distance between two angles.\n *\n * @param a0 - The first angle.\n * @param a1 - The second angle.\n * @public\n */\nexport function longAngleDist(a0: number, a1: number): number {\n\treturn PI2 - shortAngleDist(a0, a1)\n}\n\n/**\n * Interpolate an angle between two angles.\n *\n * @param a0 - The first angle.\n * @param a1 - The second angle.\n * @param t - The interpolation value.\n * @public\n */\nexport function lerpAngles(a0: number, a1: number, t: number): number {\n\treturn a0 + shortAngleDist(a0, a1) * t\n}\n\n/**\n * Get the short distance between two angles.\n *\n * @param a0 - The first angle.\n * @param a1 - The second angle.\n * @public\n */\nexport function angleDelta(a0: number, a1: number): number {\n\treturn shortAngleDist(a0, a1)\n}\n\n/**\n * Get the \"sweep\" or short distance between two points on a circle's perimeter.\n *\n * @param C - The center of the circle.\n * @param A - The first point.\n * @param B - The second point.\n * @public\n */\nexport function getSweep(C: VecLike, A: VecLike, B: VecLike): number {\n\treturn angleDelta(Vec2d.Angle(C, A), Vec2d.Angle(C, B))\n}\n\n/**\n * Clamp radians within 0 and 2PI\n *\n * @param r - The radian value.\n * @public\n */\nexport function clampRadians(r: number): number {\n\treturn (PI2 + r) % PI2\n}\n\n/**\n * Clamp rotation to even segments.\n *\n * @param r - The rotation in radians.\n * @param segments - The number of segments.\n * @public\n */\nexport function snapAngle(r: number, segments: number): number {\n\tconst seg = PI2 / segments\n\tlet ang = (Math.floor((clampRadians(r) + seg / 2) / seg) * seg) % PI2\n\tif (ang < PI) ang += PI2\n\tif (ang > PI) ang -= PI2\n\treturn ang\n}\n\n/**\n * Checks whether two angles are approximately at right-angles or parallel to each other\n *\n * @param a - Angle a (radians)\n * @param b - Angle b (radians)\n * @returns True iff the angles are approximately at right-angles or parallel to each other\n * @public\n */\nexport function areAnglesCompatible(a: number, b: number) {\n\treturn a === b || approximately((a % (Math.PI / 2)) - (b % (Math.PI / 2)), 0)\n}\n\n/**\n * Is angle c between angles a and b?\n *\n * @param a - The first angle.\n * @param b - The second angle.\n * @param c - The third angle.\n * @public\n */\nexport function isAngleBetween(a: number, b: number, c: number): boolean {\n\t// Normalize the angles to ensure they're in the same domain\n\ta = canonicalizeRotation(a)\n\tb = canonicalizeRotation(b)\n\tc = canonicalizeRotation(c)\n\n\t// Compute vectors corresponding to angles a and b\n\tconst ax = Math.cos(a)\n\tconst ay = Math.sin(a)\n\tconst bx = Math.cos(b)\n\tconst by = Math.sin(b)\n\n\t// Compute the vector corresponding to angle c\n\tconst cx = Math.cos(c)\n\tconst cy = Math.sin(c)\n\n\t// Calculate dot products\n\tconst dotAc = ax * cx + ay * cy\n\tconst dotBc = bx * cx + by * cy\n\n\t// If angle c is between a and b, both dot products should be >= 0\n\treturn dotAc >= 0 && dotBc >= 0\n}\n\n/**\n * Convert degrees to radians.\n *\n * @param d - The degree in degrees.\n * @public\n */\nexport function degreesToRadians(d: number): number {\n\treturn (d * PI) / 180\n}\n\n/**\n * Convert radians to degrees.\n *\n * @param r - The degree in radians.\n * @public\n */\nexport function radiansToDegrees(r: number): number {\n\treturn (r * 180) / PI\n}\n\n/**\n * Get the length of an arc between two points on a circle's perimeter.\n *\n * @param C - The circle's center as [x, y].\n * @param r - The circle's radius.\n * @param A - The first point.\n * @param B - The second point.\n * @public\n */\nexport function getArcLength(C: VecLike, r: number, A: VecLike, B: VecLike): number {\n\tconst sweep = getSweep(C, A, B)\n\treturn r * PI2 * (sweep / PI2)\n}\n\n/**\n * Get a point on the perimeter of a circle.\n *\n * @param cx - The center x of the circle.\n * @param cy - The center y of the circle.\n * @param r - The radius of the circle.\n * @param a - The normalized point on the circle.\n * @public\n */\nexport function getPointOnCircle(cx: number, cy: number, r: number, a: number) {\n\treturn new Vec2d(cx + r * Math.cos(a), cy + r * Math.sin(a))\n}\n/** @public */\nexport function getPolygonVertices(width: number, height: number, sides: number) {\n\tconst cx = width / 2\n\tconst cy = height / 2\n\tconst pointsOnPerimeter: Vec2d[] = []\n\tlet minX = Infinity\n\tlet minY = Infinity\n\tfor (let i = 0; i < sides; i++) {\n\t\tconst step = PI2 / sides\n\t\tconst t = -TAU + i * step\n\t\tconst x = cx + cx * Math.cos(t)\n\t\tconst y = cy + cy * Math.sin(t)\n\t\tif (x < minX) minX = x\n\t\tif (y < minY) minY = y\n\t\tpointsOnPerimeter.push(new Vec2d(x, y))\n\t}\n\n\tif (minX !== 0 || minY !== 0) {\n\t\tfor (let i = 0; i < pointsOnPerimeter.length; i++) {\n\t\t\tconst pt = pointsOnPerimeter[i]\n\t\t\tpt.x -= minX\n\t\t\tpt.y -= minY\n\t\t}\n\t}\n\n\treturn pointsOnPerimeter\n}\n\n/**\n * @param a0 - The start point in the A range\n * @param a1 - The end point in the A range\n * @param b0 - The start point in the B range\n * @param b1 - The end point in the B range\n * @returns True if the ranges overlap\n * @public\n */\nexport function rangesOverlap(a0: number, a1: number, b0: number, b1: number): boolean {\n\treturn a0 < b1 && b0 < a1\n}\n\n/**\n * Finds the intersection of two ranges.\n *\n * @param a0 - The start point in the A range\n * @param a1 - The end point in the A range\n * @param b0 - The start point in the B range\n * @param b1 - The end point in the B range\n * @returns The intersection of the ranges, or null if no intersection\n * @public\n */\nexport function rangeIntersection(\n\ta0: number,\n\ta1: number,\n\tb0: number,\n\tb1: number\n): [number, number] | null {\n\tconst min = Math.max(a0, b0)\n\tconst max = Math.min(a1, b1)\n\tif (min <= max) {\n\t\treturn [min, max]\n\t}\n\treturn null\n}\n\n/**\n * Gets the width/height of a star given its input bounds.\n *\n * @param sides - Number of sides\n * @param w - T target width\n * @param h - Target height\n * @returns Box2d\n * @public\n */\nexport const getStarBounds = (sides: number, w: number, h: number): Box2d => {\n\tconst step = PI2 / sides / 2\n\tconst rightMostIndex = Math.floor(sides / 4) * 2\n\tconst leftMostIndex = sides * 2 - rightMostIndex\n\tconst topMostIndex = 0\n\tconst bottomMostIndex = Math.floor(sides / 2) * 2\n\tconst maxX = (Math.cos(-TAU + rightMostIndex * step) * w) / 2\n\tconst minX = (Math.cos(-TAU + leftMostIndex * step) * w) / 2\n\tconst minY = (Math.sin(-TAU + topMostIndex * step) * h) / 2\n\tconst maxY = (Math.sin(-TAU + bottomMostIndex * step) * h) / 2\n\treturn new Box2d(0, 0, maxX - minX, maxY - minY)\n}\n\n/** Helper for point in polygon */\nfunction cross(x: VecLike, y: VecLike, z: VecLike): number {\n\treturn (y.x - x.x) * (z.y - x.y) - (z.x - x.x) * (y.y - x.y)\n}\n\n/**\n * Utils for working with points.\n *\n * @public\n */\n/**\n * Get whether a point is inside of a circle.\n *\n * @param A - The point to check.\n * @param C - The circle's center point as [x, y].\n * @param r - The circle's radius.\n * @returns Boolean\n * @public\n */\nexport function pointInCircle(A: VecLike, C: VecLike, r: number): boolean {\n\treturn Vec2d.Dist(A, C) <= r\n}\n\n/**\n * Get whether a point is inside of an ellipse.\n *\n * @param point - The point to check.\n * @param center - The ellipse's center point as [x, y].\n * @param rx - The ellipse's x radius.\n * @param ry - The ellipse's y radius.\n * @param rotation - The ellipse's rotation.\n * @returns Boolean\n * @public\n */\nexport function pointInEllipse(\n\tA: VecLike,\n\tC: VecLike,\n\trx: number,\n\try: number,\n\trotation = 0\n): boolean {\n\trotation = rotation || 0\n\tconst cos = Math.cos(rotation)\n\tconst sin = Math.sin(rotation)\n\tconst delta = Vec2d.Sub(A, C)\n\tconst tdx = cos * delta.x + sin * delta.y\n\tconst tdy = sin * delta.x - cos * delta.y\n\n\treturn (tdx * tdx) / (rx * rx) + (tdy * tdy) / (ry * ry) <= 1\n}\n\n/**\n * Get whether a point is inside of a rectangle.\n *\n * @param A - The point to check.\n * @param point - The rectangle's top left point as [x, y].\n * @param size - The rectangle's size as [width, height].\n * @public\n */\nexport function pointInRect(A: VecLike, point: VecLike, size: VecLike): boolean {\n\treturn !(A.x < point.x || A.x > point.x + size.x || A.y < point.y || A.y > point.y + size.y)\n}\n\n/**\n * Get whether a point is inside of a polygon.\n *\n * ```ts\n * const result = pointInPolygon(myPoint, myPoints)\n * ```\n *\n * @public\n */\nexport function pointInPolygon(A: VecLike, points: VecLike[]): boolean {\n\tlet windingNumber = 0\n\tlet a: VecLike\n\tlet b: VecLike\n\n\tfor (let i = 0; i < points.length; i++) {\n\t\ta = points[i]\n\t\tb = points[(i + 1) % points.length]\n\n\t\tif (a.y <= A.y) {\n\t\t\tif (b.y > A.y && cross(a, b, A) > 0) {\n\t\t\t\twindingNumber += 1\n\t\t\t}\n\t\t} else if (b.y <= A.y && cross(a, b, A) < 0) {\n\t\t\twindingNumber -= 1\n\t\t}\n\t}\n\n\treturn windingNumber !== 0\n}\n\n/**\n * Get whether a point is inside of a bounds.\n *\n * @param A - The point to check.\n * @param b - The bounds to check.\n * @returns Boolean\n * @public\n */\nexport function pointInBounds(A: VecLike, b: Box2d): boolean {\n\treturn !(A.x < b.minX || A.x > b.maxX || A.y < b.minY || A.y > b.maxY)\n}\n\n/**\n * Hit test a point and a polyline using a minimum distance.\n *\n * @param A - The point to check.\n * @param points - The points that make up the polyline.\n * @param distance - The mininum distance that qualifies a hit.\n * @returns Boolean\n * @public\n */\nexport function pointInPolyline(A: VecLike, points: VecLike[], distance = 3): boolean {\n\tfor (let i = 1; i < points.length; i++) {\n\t\tif (Vec2d.DistanceToLineSegment(points[i - 1], points[i], A) < distance) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n/**\n * Get whether a point is within a certain distance from a polyline.\n *\n * @param A - The point to check.\n * @param points - The points that make up the polyline.\n * @param distance - The mininum distance that qualifies a hit.\n * @public\n */\nexport function pointNearToPolyline(A: VecLike, points: VecLike[], distance = 8) {\n\tconst len = points.length\n\tfor (let i = 1; i < len; i++) {\n\t\tconst p1 = points[i - 1]\n\t\tconst p2 = points[i]\n\t\tconst d = Vec2d.DistanceToLineSegment(p1, p2, A)\n\t\tif (d < distance) return true\n\t}\n\treturn false\n}\n\n/**\n * Get whether a point is within a certain distance from a line segment.\n *\n * @param A - The point to check.\n * @param p1 - The polyline's first point.\n * @param p2 - The polyline's second point.\n * @param distance - The mininum distance that qualifies a hit.\n * @public\n */\nexport function pointNearToLineSegment(A: VecLike, p1: VecLike, p2: VecLike, distance = 8) {\n\tconst d = Vec2d.DistanceToLineSegment(p1, p2, A)\n\tif (d < distance) return true\n\treturn false\n}\n\n/**\n * Simplify a line (using Ramer-Douglas-Peucker algorithm).\n *\n * @param points - An array of points as [x, y, ...][]\n * @param tolerance - The minimum line distance (also called epsilon).\n * @returns Simplified array as [x, y, ...][]\n * @public\n */\nexport function simplify(points: VecLike[], tolerance = 1): VecLike[] {\n\tconst len = points.length\n\tconst a = points[0]\n\tconst b = points[len - 1]\n\tconst { x: x1, y: y1 } = a\n\tconst { x: x2, y: y2 } = b\n\tif (len > 2) {\n\t\tlet distance = 0\n\t\tlet index = 0\n\t\tconst max = new Vec2d(y2 - y1, x2 - x1).len2()\n\t\tfor (let i = 1; i < len - 1; i++) {\n\t\t\tconst { x: x0, y: y0 } = points[i]\n\t\t\tconst d = Math.pow(x0 * (y2 - y1) + x1 * (y0 - y2) + x2 * (y1 - y0), 2) / max\n\t\t\tif (distance > d) continue\n\t\t\tdistance = d\n\t\t\tindex = i\n\t\t}\n\t\tif (distance > tolerance) {\n\t\t\tconst l0 = simplify(points.slice(0, index + 1), tolerance)\n\t\t\tconst l1 = simplify(points.slice(index + 1), tolerance)\n\t\t\treturn l0.concat(l1.slice(1))\n\t\t}\n\t}\n\treturn [a, b]\n}\n\nfunction _getSqSegDist(p: VecLike, p1: VecLike, p2: VecLike) {\n\tlet x = p1.x\n\tlet y = p1.y\n\tlet dx = p2.x - x\n\tlet dy = p2.y - y\n\tif (dx !== 0 || dy !== 0) {\n\t\tconst t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy)\n\t\tif (t > 1) {\n\t\t\tx = p2.x\n\t\t\ty = p2.y\n\t\t} else if (t > 0) {\n\t\t\tx += dx * t\n\t\t\ty += dy * t\n\t\t}\n\t}\n\tdx = p.x - x\n\tdy = p.y - y\n\treturn dx * dx + dy * dy\n}\n\nfunction _simplifyStep(\n\tpoints: VecLike[],\n\tfirst: number,\n\tlast: number,\n\tsqTolerance: number,\n\tresult: VecLike[]\n) {\n\tlet maxSqDist = sqTolerance\n\tlet index = -1\n\tfor (let i = first + 1; i < last; i++) {\n\t\tconst sqDist = _getSqSegDist(points[i], points[first], points[last])\n\t\tif (sqDist > maxSqDist) {\n\t\t\tindex = i\n\t\t\tmaxSqDist = sqDist\n\t\t}\n\t}\n\tif (index > -1 && maxSqDist > sqTolerance) {\n\t\tif (index - first > 1) _simplifyStep(points, first, index, sqTolerance, result)\n\t\tresult.push(points[index])\n\t\tif (last - index > 1) _simplifyStep(points, index, last, sqTolerance, result)\n\t}\n}\n\n/** @public */\nexport function simplify2(points: VecLike[], tolerance = 1) {\n\tif (points.length <= 2) return points\n\tconst sqTolerance = tolerance * tolerance\n\t// Radial distance\n\tlet A = points[0]\n\tlet B = points[1]\n\tconst newPoints = [A]\n\tfor (let i = 1, len = points.length; i < len; i++) {\n\t\tB = points[i]\n\t\tif ((B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y) > sqTolerance) {\n\t\t\tnewPoints.push(B)\n\t\t\tA = B\n\t\t}\n\t}\n\tif (A !== B) newPoints.push(B)\n\t// Ramer-Douglas-Peucker\n\tconst last = newPoints.length - 1\n\tconst result = [newPoints[0]]\n\t_simplifyStep(newPoints, 0, last, sqTolerance, result)\n\tresult.push(newPoints[last], points[points.length - 1])\n\treturn result\n}\n\n/** @public */\nexport function getMinX(pts: VecLike[]) {\n\tlet top = pts[0]\n\tfor (let i = 1; i < pts.length; i++) {\n\t\tif (pts[i].x < top.x) {\n\t\t\ttop = pts[i]\n\t\t}\n\t}\n\treturn top.x\n}\n\n/** @public */\nexport function getMinY(pts: VecLike[]) {\n\tlet top = pts[0]\n\tfor (let i = 1; i < pts.length; i++) {\n\t\tif (pts[i].y < top.y) {\n\t\t\ttop = pts[i]\n\t\t}\n\t}\n\treturn top.y\n}\n\n/** @public */\nexport function getMaxX(pts: VecLike[]) {\n\tlet top = pts[0]\n\tfor (let i = 1; i < pts.length; i++) {\n\t\tif (pts[i].x > top.x) {\n\t\t\ttop = pts[i]\n\t\t}\n\t}\n\treturn top.x\n}\n\n/** @public */\nexport function getMaxY(pts: VecLike[]) {\n\tlet top = pts[0]\n\tfor (let i = 1; i < pts.length; i++) {\n\t\tif (pts[i].y > top.y) {\n\t\t\ttop = pts[i]\n\t\t}\n\t}\n\treturn top.y\n}\n\n/** @public */\nexport function getMidX(pts: VecLike[]) {\n\tconst a = getMinX(pts)\n\tconst b = getMaxX(pts)\n\n\treturn a + (b - a) / 2\n}\n\n/** @public */\nexport function getMidY(pts: VecLike[]) {\n\tconst a = getMinY(pts)\n\tconst b = getMaxY(pts)\n\n\treturn a + (b - a) / 2\n}\n\n/** @public */\nexport function getWidth(pts: VecLike[]) {\n\tconst a = getMinX(pts)\n\tconst b = getMaxX(pts)\n\treturn b - a\n}\n\n/** @public */\nexport function getHeight(pts: VecLike[]) {\n\tconst a = getMinY(pts)\n\tconst b = getMaxY(pts)\n\treturn b - a\n}\n\n/**\n * The DOM likes values to be fixed to 3 decimal places\n *\n * @public\n */\nexport function toDomPrecision(v: number) {\n\treturn +v.toFixed(4)\n}\n\n/**\n * @public\n */\nexport function toFixed(v: number) {\n\treturn +v.toFixed(2)\n}\n\n/**\n * Check if a float is safe to use. ie: Not too big or small.\n * @public\n */\nexport const isSafeFloat = (n: number) => {\n\treturn Math.abs(n) < Number.MAX_SAFE_INTEGER\n}\n"],
  "mappings": "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",
  "names": []
}
