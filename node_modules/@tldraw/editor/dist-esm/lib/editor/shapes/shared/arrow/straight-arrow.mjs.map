{
  "version": 3,
  "sources": ["../../../../../../src/lib/editor/shapes/shared/arrow/straight-arrow.ts"],
  "sourcesContent": ["import { TLArrowShape } from '@tldraw/tlschema'\nimport { Box2d } from '../../../../primitives/Box2d'\nimport { Matrix2d, Matrix2dModel } from '../../../../primitives/Matrix2d'\nimport { Vec2d, VecLike } from '../../../../primitives/Vec2d'\nimport {\n\tintersectLineSegmentPolygon,\n\tintersectLineSegmentPolyline,\n} from '../../../../primitives/intersect'\nimport { Editor } from '../../../Editor'\nimport { TLArrowInfo } from './arrow-types'\nimport {\n\tBOUND_ARROW_OFFSET,\n\tBoundShapeInfo,\n\tMIN_ARROW_LENGTH,\n\tSTROKE_SIZES,\n\tgetArrowTerminalsInArrowSpace,\n\tgetBoundShapeInfoForTerminal,\n} from './shared'\n\nexport function getStraightArrowInfo(editor: Editor, shape: TLArrowShape): TLArrowInfo {\n\tconst { start, end, arrowheadStart, arrowheadEnd } = shape.props\n\n\tconst terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape)\n\n\tconst a = terminalsInArrowSpace.start.clone()\n\tconst b = terminalsInArrowSpace.end.clone()\n\tconst c = Vec2d.Med(a, b)\n\tconst uAB = Vec2d.Sub(b, a).uni()\n\n\t// Update the arrowhead points using intersections with the bound shapes, if any.\n\n\tconst startShapeInfo = getBoundShapeInfoForTerminal(editor, start)\n\tconst endShapeInfo = getBoundShapeInfoForTerminal(editor, end)\n\n\tconst arrowPageTransform = editor.getShapePageTransform(shape)!\n\n\t// Update the position of the arrowhead's end point\n\tupdateArrowheadPointWithBoundShape(\n\t\tb, // <-- will be mutated\n\t\tterminalsInArrowSpace.start,\n\t\tarrowPageTransform,\n\t\tendShapeInfo\n\t)\n\n\t// Then update the position of the arrowhead's end point\n\tupdateArrowheadPointWithBoundShape(\n\t\ta, // <-- will be mutated\n\t\tterminalsInArrowSpace.end,\n\t\tarrowPageTransform,\n\t\tstartShapeInfo\n\t)\n\n\tlet offsetA = 0\n\tlet offsetB = 0\n\n\tconst isSelfIntersection =\n\t\tstartShapeInfo && endShapeInfo && startShapeInfo.shape === endShapeInfo.shape\n\n\tif (\n\t\tstartShapeInfo &&\n\t\tendShapeInfo &&\n\t\t!isSelfIntersection &&\n\t\t!startShapeInfo.isExact &&\n\t\t!endShapeInfo.isExact\n\t) {\n\t\tif (endShapeInfo.didIntersect && !startShapeInfo.didIntersect) {\n\t\t\t// ...and if only the end shape intersected, then make it\n\t\t\t// a short arrow ending at the end shape intersection.\n\t\t\tif (startShapeInfo.isClosed) {\n\t\t\t\ta.setTo(b.clone().add(uAB.clone().mul(MIN_ARROW_LENGTH)))\n\t\t\t}\n\t\t} else if (!endShapeInfo.didIntersect) {\n\t\t\t// ...and if only the end shape intersected, or if neither\n\t\t\t// shape intersected, then make it a short arrow starting\n\t\t\t// at the start shape intersection.\n\t\t\tif (endShapeInfo.isClosed) {\n\t\t\t\tb.setTo(a.clone().sub(uAB.clone().mul(MIN_ARROW_LENGTH)))\n\t\t\t}\n\t\t}\n\t}\n\n\tconst u = Vec2d.Sub(b, a).uni()\n\tconst didFlip = !Vec2d.Equals(u, uAB)\n\n\t// If the arrow is bound non-exact to a start shape and the\n\t// start point has an arrowhead offset the start point\n\tif (!isSelfIntersection) {\n\t\tif (startShapeInfo && arrowheadStart !== 'none' && !startShapeInfo.isExact) {\n\t\t\toffsetA =\n\t\t\t\tBOUND_ARROW_OFFSET +\n\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t('size' in startShapeInfo.shape.props\n\t\t\t\t\t? STROKE_SIZES[startShapeInfo.shape.props.size] / 2\n\t\t\t\t\t: 0)\n\t\t}\n\n\t\t// If the arrow is bound non-exact to an end shape and the\n\t\t// end point has an arrowhead offset the end point\n\t\tif (endShapeInfo && arrowheadEnd !== 'none' && !endShapeInfo.isExact) {\n\t\t\toffsetB =\n\t\t\t\tBOUND_ARROW_OFFSET +\n\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t('size' in endShapeInfo.shape.props ? STROKE_SIZES[endShapeInfo.shape.props.size] / 2 : 0)\n\t\t}\n\t}\n\n\tconst tA = a.clone().add(u.clone().mul(offsetA * (didFlip ? -1 : 1)))\n\tconst tB = b.clone().sub(u.clone().mul(offsetB * (didFlip ? -1 : 1)))\n\tconst distAB = Vec2d.Dist(tA, tB)\n\tif (distAB < MIN_ARROW_LENGTH) {\n\t\tif (offsetA !== 0 && offsetB !== 0) {\n\t\t\toffsetA *= -1.5\n\t\t\toffsetB *= -1.5\n\t\t} else if (offsetA !== 0) {\n\t\t\toffsetA *= -2\n\t\t} else if (offsetB !== 0) {\n\t\t\toffsetB *= -2\n\t\t} else {\n\t\t\tif (distAB < 10) {\n\t\t\t\tif (startShapeInfo) offsetA = -(10 - distAB)\n\t\t\t\telse if (endShapeInfo) offsetB = -(10 - distAB)\n\t\t\t}\n\t\t}\n\t}\n\n\ta.add(u.clone().mul(offsetA * (didFlip ? -1 : 1)))\n\tb.sub(u.clone().mul(offsetB * (didFlip ? -1 : 1)))\n\n\t// If the handles flipped their order, then set the center handle\n\t// to the midpoint of the terminals (rather than the midpoint of the\n\t// arrow body); otherwise, it may not be \"between\" the other terminals.\n\tif (didFlip) {\n\t\tif (startShapeInfo && endShapeInfo) {\n\t\t\t// If we have two bound shapes...then make the arrow a short arrow from\n\t\t\t// the start point towards where the end point should be.\n\t\t\tb.setTo(Vec2d.Add(a, u.clone().mul(-MIN_ARROW_LENGTH)))\n\t\t}\n\t\tc.setTo(Vec2d.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end))\n\t} else {\n\t\tc.setTo(Vec2d.Med(a, b))\n\t}\n\n\tconst length = Vec2d.Dist(a, b)\n\n\treturn {\n\t\tisStraight: true,\n\t\tstart: {\n\t\t\thandle: terminalsInArrowSpace.start,\n\t\t\tpoint: a,\n\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t},\n\t\tend: {\n\t\t\thandle: terminalsInArrowSpace.end,\n\t\t\tpoint: b,\n\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t},\n\t\tmiddle: c,\n\t\tisValid: length > 0,\n\t\tlength,\n\t}\n}\n\n/** Get an intersection point from A -> B with bound shape (target) from shape (arrow). */\nfunction updateArrowheadPointWithBoundShape(\n\tpoint: Vec2d,\n\topposite: Vec2d,\n\tarrowPageTransform: Matrix2dModel,\n\ttargetShapeInfo?: BoundShapeInfo\n) {\n\tif (targetShapeInfo === undefined) {\n\t\t// No bound shape? The arrowhead point will be at the arrow terminal.\n\t\treturn\n\t}\n\n\tif (targetShapeInfo.isExact) {\n\t\t// Exact type binding? The arrowhead point will be at the arrow terminal.\n\t\treturn\n\t}\n\n\t// From and To in page space\n\tconst pageFrom = Matrix2d.applyToPoint(arrowPageTransform, opposite)\n\tconst pageTo = Matrix2d.applyToPoint(arrowPageTransform, point)\n\n\t// From and To in local space of the target shape\n\tconst targetFrom = Matrix2d.applyToPoint(Matrix2d.Inverse(targetShapeInfo.transform), pageFrom)\n\tconst targetTo = Matrix2d.applyToPoint(Matrix2d.Inverse(targetShapeInfo.transform), pageTo)\n\n\tconst isClosed = targetShapeInfo.isClosed\n\tconst fn = isClosed ? intersectLineSegmentPolygon : intersectLineSegmentPolyline\n\n\tconst intersection = fn(targetFrom, targetTo, targetShapeInfo.outline)\n\n\tlet targetInt: VecLike | undefined\n\n\tif (intersection !== null) {\n\t\ttargetInt =\n\t\t\tintersection.sort((p1, p2) => Vec2d.Dist(p1, targetFrom) - Vec2d.Dist(p2, targetFrom))[0] ??\n\t\t\t(isClosed ? undefined : targetTo)\n\t}\n\n\tif (targetInt === undefined) {\n\t\t// No intersection? The arrowhead point will be at the arrow terminal.\n\t\treturn\n\t}\n\n\tconst pageInt = Matrix2d.applyToPoint(targetShapeInfo.transform, targetInt)\n\tconst arrowInt = Matrix2d.applyToPoint(Matrix2d.Inverse(arrowPageTransform), pageInt)\n\n\tpoint.setTo(arrowInt)\n\n\ttargetShapeInfo.didIntersect = true\n}\n\n/** @public */\nexport function getStraightArrowHandlePath(info: TLArrowInfo & { isStraight: true }) {\n\treturn getArrowPath(info.start.handle, info.end.handle)\n}\n\n/** @public */\nexport function getSolidStraightArrowPath(info: TLArrowInfo & { isStraight: true }) {\n\treturn getArrowPath(info.start.point, info.end.point)\n}\n\nfunction getArrowPath(start: VecLike, end: VecLike) {\n\treturn `M${start.x},${start.y}L${end.x},${end.y}`\n}\n\n/** @public */\nexport function getStraightArrowBoundingBox(start: VecLike, end: VecLike) {\n\treturn new Box2d(\n\t\tMath.min(start.x, end.x),\n\t\tMath.min(start.y, end.y),\n\t\tMath.abs(start.x - end.x),\n\t\tMath.abs(start.y - end.y)\n\t)\n}\n"],
  "mappings": "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",
  "names": []
}
