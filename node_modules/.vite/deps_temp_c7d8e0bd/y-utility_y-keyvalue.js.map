{
  "version": 3,
  "sources": ["../../y-utility/node_modules/lib0/map.js", "../../y-utility/node_modules/lib0/set.js", "../../y-utility/node_modules/lib0/array.js", "../../y-utility/node_modules/lib0/observable.js", "../../y-utility/y-keyvalue.js"],
  "sourcesContent": ["/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nexport const create = () => new Map()\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template X,Y\n * @param {Map<X,Y>} m\n * @return {Map<X,Y>}\n */\nexport const copy = m => {\n  const r = create()\n  m.forEach((v, k) => { r.set(k, v) })\n  return r\n}\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template V,K\n * @template {Map<K,V>} MAP\n * @param {MAP} map\n * @param {K} key\n * @param {function():V} createT\n * @return {V}\n */\nexport const setIfUndefined = (map, key, createT) => {\n  let set = map.get(key)\n  if (set === undefined) {\n    map.set(key, set = createT())\n  }\n  return set\n}\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nexport const map = (m, f) => {\n  const res = []\n  for (const [key, value] of m) {\n    res.push(f(value, key))\n  }\n  return res\n}\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n}\n", "/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nexport const create = () => new Set()\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nexport const toArray = set => Array.from(set)\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {T}\n */\nexport const first = set =>\n  set.values().next().value || undefined\n\n/**\n * @template T\n * @param {Iterable<T>} entries\n * @return {Set<T>}\n */\nexport const from = entries => new Set(entries)\n", "/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\nimport * as set from './set.js'\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {ArrayLike<L>} arr\n * @return {L}\n */\nexport const last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nexport const create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nexport const copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nexport const appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nexport const from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template ITEM\n * @template {ArrayLike<ITEM>} ARR\n *\n * @param {ARR} arr\n * @param {function(ITEM, number, ARR):boolean} f\n * @return {boolean}\n */\nexport const every = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (!f(arr[i], i, arr)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template S\n * @template {ArrayLike<S>} ARR\n * @param {ARR} arr\n * @param {function(S, number, ARR):boolean} f\n * @return {boolean}\n */\nexport const some = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (f(arr[i], i, arr)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @template ELEM\n *\n * @param {ArrayLike<ELEM>} a\n * @param {ArrayLike<ELEM>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nexport const flatten = arr => fold(arr, /** @type {Array<ELEM>} */ ([]), (acc, val) => acc.concat(val))\n\n/**\n * @template T\n * @param {number} len\n * @param {function(number, Array<T>):T} f\n * @return {Array<T>}\n */\nexport const unfold = (len, f) => {\n  const array = new Array(len)\n  for (let i = 0; i < len; i++) {\n    array[i] = f(i, array)\n  }\n  return array\n}\n\n/**\n * @template T\n * @template RESULT\n * @param {Array<T>} arr\n * @param {RESULT} seed\n * @param {function(RESULT, T, number):RESULT} folder\n */\nexport const fold = (arr, seed, folder) => arr.reduce(folder, seed)\n\nexport const isArray = Array.isArray\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {Array<T>}\n */\nexport const unique = arr => from(set.from(arr))\n\n/**\n * @template T\n * @template M\n * @param {ArrayLike<T>} arr\n * @param {function(T):M} mapper\n * @return {Array<T>}\n */\nexport const uniqueBy = (arr, mapper) => {\n  /**\n   * @type {Set<M>}\n   */\n  const happened = set.create()\n  /**\n   * @type {Array<T>}\n   */\n  const result = []\n  for (let i = 0; i < arr.length; i++) {\n    const el = arr[i]\n    const mapped = mapper(el)\n    if (!happened.has(mapped)) {\n      happened.add(mapped)\n      result.push(el)\n    }\n  }\n  return result\n}\n\n/**\n * @template {ArrayLike<any>} ARR\n * @template {function(ARR extends ArrayLike<infer T> ? T : never, number, ARR):any} MAPPER\n * @param {ARR} arr\n * @param {MAPPER} mapper\n * @return {Array<MAPPER extends function(...any): infer M ? M : never>}\n */\nexport const map = (arr, mapper) => {\n  /**\n   * @type {Array<any>}\n   */\n  const res = Array(arr.length)\n  for (let i = 0; i < arr.length; i++) {\n    res[i] = mapper(/** @type {any} */ (arr[i]), i, /** @type {any} */ (arr))\n  }\n  return /** @type {any} */ (res)\n}\n", "/**\n * Observable class prototype.\n *\n * @module observable\n */\n\nimport * as map from './map.js'\nimport * as set from './set.js'\nimport * as array from './array.js'\n\n/**\n * Handles named events.\n * @experimental\n *\n * This is basically a (better typed) duplicate of Observable, which will replace Observable in the\n * next release.\n *\n * @template {{[key: string]: function(...any):void}} EVENTS\n */\nexport class ObservableV2 {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<string, Set<any>>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @template {string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, /** @type {string} */ (name), set.create).add(f)\n    return f\n  }\n\n  /**\n   * @template {string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, /** @type {any} */ (_f))\n      f(...args)\n    }\n    this.on(name, /** @type {any} */ (_f))\n  }\n\n  /**\n   * @template {string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @template {string} NAME\n   * @param {NAME} name The event name.\n   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n\n/* c8 ignore start */\n/**\n * Handles named events.\n *\n * @deprecated\n * @template N\n */\nexport class Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, name, set.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n/* c8 ignore end */\n", "import * as Y from 'yjs' // eslint-disable-line\nimport { Observable } from 'lib0/observable'\n\n/**\n * @template T\n * @extends Observable<'change'>\n *\n * Yjs maps don't perform well when there are a lot of entries that are frequently updated in alternating order.\n * This is a more efficient key-value store that allows frequently updating alternating entries.\n *\n * Note that this implementation does not support any nested Yjs types.\n *\n * Rough concept: We store { key, val } pairs in an Y.Array. When you write a new entry,\n * we append the { key, val } pair to the yarray and remove all existing entries with the same key.\n * Items that are more to the right have precedence.\n *\n * This type fires events similarly to Y.Map\n *\n * ```js\n * yefficientmap.on('change', changes => {\n *   changes // => Map<string, { action: 'delete', oldValue: T } | { action: 'update', oldValue: T, newValue: T } | { action: 'add', newValue: T }>\n * })\n * ```\n */\nexport class YKeyValue extends Observable {\n  /**\n   * @param {Y.Array<{ key: string, val: T }>} yarray\n   */\n  constructor (yarray) {\n    super()\n    this.yarray = yarray\n    this.doc = /** @type {Y.Doc} */ (yarray.doc)\n    /**\n     * Store the key-val pair so we can do identity-based comparisons.\n     *\n     * @type {Map<string, { key: string, val: T }>}\n     */\n    this.map = new Map()\n    {\n      // initialize the map and cleanup duplicate items\n      const arr = yarray.toArray()\n      this.doc.transact(() => {\n        for (let i = arr.length - 1; i >= 0; i--) {\n          const v = arr[i]\n          if (this.map.has(v.key)) {\n            // entry already exists, remove the current item\n            yarray.delete(i)\n          } else {\n            this.map.set(v.key, v)\n          }\n        }\n      })\n    }\n    // track when new items are added/removed and update this.map\n    yarray.observe((event, tr) => {\n      /**\n       * This is the change-event we calculate. It works similarly to Y.MapEvent.keys (I added support for newValue)\n       *\n       * https://docs.yjs.dev/api/shared-types/y.map\n       *\n       * @type {Map<string, { action: 'delete', oldValue: T } | { action: 'update', oldValue: T, newValue: T } | { action: 'add', newValue: T }>}\n       */\n      const changes = new Map()\n      /**\n       * @type {Array<Y.Item>}\n       */\n      const addedItems = Array.from(event.changes.added)\n      event.changes.deleted.forEach(ditem => {\n        ditem.content.getContent().forEach(c => {\n          // deleted item was the current value\n          if (this.map.get(c.key) === c) {\n            this.map.delete(c.key)\n            changes.set(c.key, { action: 'delete', oldValue: c.val })\n          }\n        })\n      })\n      /**\n       * @type {Map<string, { key: string, val: T }>}\n       */\n      const addedVals = new Map()\n      addedItems.map(item => item.content.getContent()).flat().forEach(v => {\n        addedVals.set(v.key, v)\n      })\n\n      /**\n       * A set of ids to remove.\n       *\n       * If an item was added, but it doesn't overwrite something\n       * (because an older item is more to the right),\n       * we will remove it in the cleanup process.\n       *\n       * We don't know the index, so we have to cache it here.\n       *\n       * @type {Set<string>}\n       */\n      const itemsToRemove = new Set()\n      const vals = yarray.toArray()\n      this.doc.transact(_tr => {\n        /**\n         * Iterate from right to left and update the map while we find the items in addedVals\n         */\n        for (let i = vals.length - 1; i >= 0 && (addedVals.size > 0 || itemsToRemove.size > 0); i--) {\n          const currVal = vals[i]\n          if (itemsToRemove.has(currVal.key)) {\n            itemsToRemove.delete(currVal.key)\n            yarray.delete(i, 1)\n          } else if (addedVals.get(currVal.key) === currVal) {\n            // a new item was inserted that is the latest value\n            const prevValue = this.map.get(currVal.key)\n            if (prevValue) {\n              // There was an entry that existed before.\n              // We just have to delete the previous item\n              itemsToRemove.add(currVal.key)\n              // and fire an \"update\" event\n              changes.set(currVal.key, { action: 'update', oldValue: prevValue.val, newValue: currVal.val })\n            } else {\n              // if the item was properly updated, there should already be a 'delete' event\n              const delEvent = changes.get(currVal.key)\n              if (delEvent && delEvent.action === 'delete') {\n                changes.set(currVal.key, { action: 'update', newValue: currVal.val, oldValue: delEvent.oldValue })\n              } else {\n                // fire an \"add\" event\n                changes.set(currVal.key, { action: 'add', newValue: currVal.val })\n              }\n            }\n            addedVals.delete(currVal.key)\n            this.map.set(currVal.key, currVal)\n          } else if (addedVals.has(currVal.key)) {\n            // The entry didn't change, we have to remove the added value\n            itemsToRemove.add(currVal.key)\n            addedVals.delete(currVal.key)\n          }\n        }\n      })\n      if (changes.size > 0) {\n        this.emit('change', [changes, tr])\n      }\n    })\n  }\n\n  /**\n   * @param {string} key\n   * @param {T} val\n   */\n  set (key, val) {\n    this.doc.transact(_tr => {\n      // if this value existed before, we will delete it first\n      if (this.map.has(key)) {\n        this.delete(key)\n      }\n      this.yarray.push([{ key, val }])\n    })\n  }\n\n  /**\n   * @param {string} key\n   */\n  delete (key) {\n    let i = 0\n    // eslint-disable-next-line no-unused-vars\n    for (const val of this.yarray) {\n      if (val.key === key) {\n        this.yarray.delete(i)\n        break\n      }\n      i++\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @return {T | undefined}\n   */\n  get (key) {\n    const v = this.map.get(key)\n    return v && v.val\n  }\n\n  /**\n   * @param {string} key\n   */\n  has (key) {\n    return this.map.has(key)\n  }\n}\n"],
  "mappings": "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",
  "names": ["create", "from", "create", "from"]
}
