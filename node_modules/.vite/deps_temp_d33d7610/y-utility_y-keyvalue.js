import "./chunk-BEBG7BGF.js";
import "./chunk-ZC22LKFR.js";

// node_modules/y-utility/node_modules/lib0/map.js
var create = () => /* @__PURE__ */ new Map();
var setIfUndefined = (map, key, createT) => {
  let set = map.get(key);
  if (set === void 0) {
    map.set(key, set = createT());
  }
  return set;
};

// node_modules/y-utility/node_modules/lib0/set.js
var create2 = () => /* @__PURE__ */ new Set();

// node_modules/y-utility/node_modules/lib0/array.js
var from2 = Array.from;
var isArray = Array.isArray;

// node_modules/y-utility/node_modules/lib0/observable.js
var Observable = class {
  constructor() {
    this._observers = create();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(name, f) {
    setIfUndefined(this._observers, name, create2).add(f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(name, f) {
    const _f = (...args) => {
      this.off(name, _f);
      f(...args);
    };
    this.on(name, _f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(name, args) {
    return from2((this._observers.get(name) || create()).values()).forEach((f) => f(...args));
  }
  destroy() {
    this._observers = create();
  }
};

// node_modules/y-utility/y-keyvalue.js
var YKeyValue = class extends Observable {
  /**
   * @param {Y.Array<{ key: string, val: T }>} yarray
   */
  constructor(yarray) {
    super();
    this.yarray = yarray;
    this.doc = /** @type {Y.Doc} */
    yarray.doc;
    this.map = /* @__PURE__ */ new Map();
    {
      const arr = yarray.toArray();
      this.doc.transact(() => {
        for (let i = arr.length - 1; i >= 0; i--) {
          const v = arr[i];
          if (this.map.has(v.key)) {
            yarray.delete(i);
          } else {
            this.map.set(v.key, v);
          }
        }
      });
    }
    yarray.observe((event, tr) => {
      const changes = /* @__PURE__ */ new Map();
      const addedItems = Array.from(event.changes.added);
      event.changes.deleted.forEach((ditem) => {
        ditem.content.getContent().forEach((c) => {
          if (this.map.get(c.key) === c) {
            this.map.delete(c.key);
            changes.set(c.key, { action: "delete", oldValue: c.val });
          }
        });
      });
      const addedVals = /* @__PURE__ */ new Map();
      addedItems.map((item) => item.content.getContent()).flat().forEach((v) => {
        addedVals.set(v.key, v);
      });
      const itemsToRemove = /* @__PURE__ */ new Set();
      const vals = yarray.toArray();
      this.doc.transact((_tr) => {
        for (let i = vals.length - 1; i >= 0 && (addedVals.size > 0 || itemsToRemove.size > 0); i--) {
          const currVal = vals[i];
          if (itemsToRemove.has(currVal.key)) {
            itemsToRemove.delete(currVal.key);
            yarray.delete(i, 1);
          } else if (addedVals.get(currVal.key) === currVal) {
            const prevValue = this.map.get(currVal.key);
            if (prevValue) {
              itemsToRemove.add(currVal.key);
              changes.set(currVal.key, { action: "update", oldValue: prevValue.val, newValue: currVal.val });
            } else {
              const delEvent = changes.get(currVal.key);
              if (delEvent && delEvent.action === "delete") {
                changes.set(currVal.key, { action: "update", newValue: currVal.val, oldValue: delEvent.oldValue });
              } else {
                changes.set(currVal.key, { action: "add", newValue: currVal.val });
              }
            }
            addedVals.delete(currVal.key);
            this.map.set(currVal.key, currVal);
          } else if (addedVals.has(currVal.key)) {
            itemsToRemove.add(currVal.key);
            addedVals.delete(currVal.key);
          }
        }
      });
      if (changes.size > 0) {
        this.emit("change", [changes, tr]);
      }
    });
  }
  /**
   * @param {string} key
   * @param {T} val
   */
  set(key, val) {
    this.doc.transact((_tr) => {
      if (this.map.has(key)) {
        this.delete(key);
      }
      this.yarray.push([{ key, val }]);
    });
  }
  /**
   * @param {string} key
   */
  delete(key) {
    let i = 0;
    for (const val of this.yarray) {
      if (val.key === key) {
        this.yarray.delete(i);
        break;
      }
      i++;
    }
  }
  /**
   * @param {string} key
   * @return {T | undefined}
   */
  get(key) {
    const v = this.map.get(key);
    return v && v.val;
  }
  /**
   * @param {string} key
   */
  has(key) {
    return this.map.has(key);
  }
};
export {
  YKeyValue
};
//# sourceMappingURL=y-utility_y-keyvalue.js.map
